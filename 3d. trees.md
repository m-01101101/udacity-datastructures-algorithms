# Trees

A tree is really an extension of a linked list. Rather than having one next element, a tree can have several. The head of the tree is known as the root and can link to several nodes.

<img src="md_refs/trees1.png" width="400">

A tree organises values hierarchically.

## Characteristics and terminology of trees

(1) A tree must be `completely connected`, i.e. if you are starting from the root, you must be able to reach every node in the tree.

(2) There must be no cycles in trees. A cycle is when there is a loop in the tree, you encounter the same node twice.

(3) Nodes in a tree are described as having a parent child relationship. Children only have one parent. The nodes without any children are leaf nodes, or external nodes.

(4) Levels starts at 1, this is the root.

(5) Connections between nodes are edges. Edges taken together represent a path.

(6) The height of a node is the number of edges between it and the further edge on the tree. A leaf has a height of 0. The root will represent the height of the tree.

(7) The depth of a node is the number of edge to the root node. Height and depth are inverses of one another.

<img src="md_refs/trees2.png" width="400"> <img src="md_refs/trees8.png" width="400">

## Traversing trees

Unlike lists, trees are not linear structures, so there's no clear way to traverse every element. Should we do everything at the same level first, or do to the furtherest depth first and come back up?

Two main approaches;

### (1) DFS - depth first search

Explore the children node first.

There are several approaches this might take.

**Pre-order traversal** is one form of DFS, "check off a node and visit it's children as you see it before you traverse any further in the tree." Head left until you hit a leaf. Then you can go back up and explore further children of that parent node.

> Visit the current node, then walk the left subtree, and finally walk the right subtree.

<img src="md_refs/trees4.png" width="400">

**In-order traversal** is another form of DFS. Though we explore nodes in the same order as a `pre-order traversal`, we do not **check off** a node until we have explored it's left most child and come back to it.

> Walk the left subtree first, then visit the current node, and finally walk the right subtree.

In this case we don't mark _B_ until we've seen _A_. It's "in-order" because we go from the left most to the right most in-order.

<img src="md_refs/trees5.png" width="400">

**Post-order traversal** - we don't check off a node until we've seen all of it's descendants.

> Walk the left subtree, then the right subtree, and finally visit the current node.

<img src="md_refs/trees6.png" width="400">

### (2) BFS - breadth first search

The priority is visiting every node on the same level, before visiting child nodes.

**Level order traversal** is a BFS with a more exact algorithm to implement.

By convention we start on the left, and move right.

<img src="md_refs/trees3.png" width="400">

## Binary trees

Binary trees are those were nodes have at most two children.

Nodes have 0, 1, or 2 children.

<img src="md_refs/trees9.png" width="400">

- A full binary tree is a binary tree where every node has exactly 0 or 2 children.

- A perfect binary tree doesn't have room for any more nodesâ€”unless we increase the tree's height.

- A complete binary tree is like a perfect binary tree missing a few nodes in the last level. Nodes are filled in from left to right.

> Complete trees are the basis for heaps and priority queues.

<img src="md_refs/trees10.png" width="400">

### Deleting a node

When we delete an element from a tree we need to make a decision of how we maintain the structure.

- Deleting a leaf is straight forward and requires no further consideration
- However if the node has a child we could delete delete the node and attach the child node to the deleted parent's node. Effectively promoting the node up a layer.
- If the node has multiple sub-children, we could promote of the nodes up the stack.
- If there is a long, complex tree, we could just shift any disconnected node in place of the deleted node. This requires some shuffling of elements.

### Inserting a node

When inserting to a binary tree, we just need to keep in mind the 2 child rule. We keep traversing down the tree until we find an empty spot where we can append the new node.

As the tree grows, each level can hold double the number of element than the previous level, because each node can have two children.

Level 1 = 1^2

Level 2 = 2^2

Level 3 = 4^2

This is $O(log(n))$

## Specific types of trees

We can introduce rules into how elements in our tree are ordered to make certain tasks faster and more efficient.

### Binary search tree (BST)

Just as an array is a type of list, a Binary Search Tree is a type of Binary Tree.

Values in BSTs are sorted, from smallest to largest, left to right. Therefore, the value of all nodes to the left of any node will be smaller, and the value of all nodes to the right will be larger.

This makes operations like search and insert very fast. We only only have to look at one value in each value, and we know if we should move left or right. The run time is therefore equal to the height of a tree $O(log(n))$. Deletion is not guaranteed to be straight forward but is more likely to be so in a BST.

This is a legitimate BST, as all nodes have no more than 2 children, and every element to the left is smaller. Though it looks odd, it's known as an _unbalanced_ binary tree. Since the distribution of nodes is skewed. This is the worst case for a BST as operations will take linear time.

<img src="md_refs/trees7.png" width="400">

## Relationship between height and number of nodes

The number of nodes available on each level is $2^n$, where $n$ represents the level.

Level 0: $2^0 = 1$

Level 1: $2^1 = 2$

Level 2: $2^2 = 4$

Level 3: $2^3 = 8$

The level is equivalent to the height $h$ of a tree, so we can solve for the number of nodes $n$, using $h$;

$n = 2^h - 1$

$n + 1 = 2^h$

$\log_2 ((n + 1)) = \log_2 (2^h)$

$\log_2 (n + 1) = h$

> A perfect tree is balanced, and in a perfect tree the height grows logarithmically with the number of nodes.
